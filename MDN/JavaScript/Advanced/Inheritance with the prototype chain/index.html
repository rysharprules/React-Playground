<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Inheritance with the prototype chain</title>
</head>
<body>
<script>
// ===================== # Inheritance with the prototype chain ===============
console.log("# Inheritance with the prototype chain");
// ===================== ## Inheriting properties =============================
console.log("## Inheriting properties");

// Let's create an object o from function f with its own properties a and b:
let f = function () {
   this.a = 1;
   this.b = 2;
}
let o = new f(); // {a: 1, b: 2}

// add properties in f function's prototype
f.prototype.b = 3;
f.prototype.c = 4;

// do not set the prototype f.prototype = {b:3,c:4}; this will break the prototype chain
// o.[[Prototype]] has properties b and c.
// o.[[Prototype]].[[Prototype]] is Object.prototype.
// Finally, o.[[Prototype]].[[Prototype]].[[Prototype]] is null.
// This is the end of the prototype chain, as null,
// by definition, has no [[Prototype]].
// Thus, the full prototype chain looks like:
// {a: 1, b: 2} ---> {b: 3, c: 4} ---> Object.prototype ---> null

console.log(o.a); // 1
// Is there an 'a' own property on o? Yes, and its value is 1.

console.log(o.b); // 2
// Is there a 'b' own property on o? Yes, and its value is 2.
// The prototype also has a 'b' property, but it's not visited.
// This is called "property shadowing."

console.log(o.c); // 4
// Is there a 'c' own property on o? No, check its prototype.
// Is there a 'c' own property on o.[[Prototype]]? Yes, its value is 4.

console.log(o.d); // undefined
// Is there a 'd' own property on o? No, check its prototype.
// Is there a 'd' own property on o.[[Prototype]]? No, check its prototype.
// o.[[Prototype]].[[Prototype]] is null, stop searching,
// no property found, return undefined.

// ========================= ## Inheriting "methods" =========================
console.log("## Inheriting \"methods\"");

var o2 = {
  a: 2,
  m: function() {
    return this.a + 1;
  }
};

console.log(o2.m()); // 3
// When calling o2.m in this case, 'this' refers to o2

var p = Object.create(o2);
// p is an object that inherits from o2

p.a = 4; // creates a property 'a' on p
console.log(p.m()); // 5
// when p.m is called, 'this' refers to p.
// So when p inherits the function m of o2,
// 'this.a' means p.a, the property 'a' of p

// ========================= # Using prototypes in JavaScript ================
console.log("# Using prototypes in JavaScript");

function doNothing(){}
console.log( doNothing.prototype );
// It does not matter how you declare the function, a
//  function in javascript will always have a default
//  prototype property.
var doNothing = function(){};
console.log( doNothing.prototype );
// prints out two doNothings:
<!--{-->
    <!--constructor: ƒ doNothing(),--> // Note the second doNothing has an unnamed constructor
    <!--__proto__: {-->
        <!--constructor: ƒ Object(),-->
        <!--hasOwnProperty: ƒ hasOwnProperty(),-->
        <!--isPrototypeOf: ƒ isPrototypeOf(),-->
        <!--propertyIsEnumerable: ƒ propertyIsEnumerable(),-->
        <!--toLocaleString: ƒ toLocaleString(),-->
        <!--toString: ƒ toString(),-->
        <!--valueOf: ƒ valueOf()-->
    <!--}-->
<!--}-->

function doSomething(){}
doSomething.prototype.foo = "bar"; // add a property onto the prototype
var doSomeInstancing = new doSomething();
doSomeInstancing.prop = "some value"; // add a property onto the object
console.log( doSomeInstancing );
<!--{-->
    <!--prop: "some value",-->
    <!--__proto__: {-->
        <!--foo: "bar",-->
        <!--constructor: ƒ doSomething(),-->
        <!--__proto__: {-->
            <!--constructor: ƒ Object(),-->
            <!--hasOwnProperty: ƒ hasOwnProperty(),-->
            <!--isPrototypeOf: ƒ isPrototypeOf(),-->
            <!--propertyIsEnumerable: ƒ propertyIsEnumerable(),-->
            <!--toLocaleString: ƒ toLocaleString(),-->
            <!--toString: ƒ toString(),-->
            <!--valueOf: ƒ valueOf()-->
        <!--}-->
    <!--}-->
<!--}-->

function doSomethingElse(){}
doSomethingElse.prototype.foo = "bar";
var doSomeOtherInstancing = new doSomethingElse();
doSomeOtherInstancing.prop = "some value";
console.log("doSomeOtherInstancing.prop:      " + doSomeOtherInstancing.prop); // some value
console.log("doSomeOtherInstancing.foo:       " + doSomeOtherInstancing.foo); // bar
console.log("doSomethingElse.prop:           " + doSomethingElse.prop); // undefined
console.log("doSomethingElse.foo:            " + doSomethingElse.foo); // undefined
console.log("doSomethingElse.prototype.prop: " + doSomethingElse.prototype.prop); // undefined
console.log("doSomethingElse.prototype.foo:  " + doSomethingElse.prototype.foo); // bar

</script>
</body>
</html>